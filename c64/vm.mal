class Vm
{
    init(chunk)
    {
        me.chunk = chunk
        me.ip = 0
        me.stack = []
        me.variables = []
        for x in [0..65536]
            me.variables << 0
    }

    //TODO: placeholder
    getVariableIndex(name)
    {
        var byte1 = 0
        var byte2 = 0

        name = upper(name)

        if len(name) == 1 then 
        {
            byte1 = 0
            byte2 = ascii(name[0])
        }
        else
        {
            byte1 = ascii(name[0])
            byte2 = ascii(name[1])
        }

        return byte1 * 128 + byte2
        
    }
    runtimeError(message)
    {
        me.error = message
        print message
    }

    gotoLine(number)
    {
        var startip = 0
        if number > me.chunk[me.ip].line_number and me.ip < len(me.chunk)-1 then startip = me.ip + 1
        //print "len chunk: %{len(me.chunk)}"
        for i in [startip..len(me.chunk)-1]
        {
            //print "i: %{i}"
            if me.chunk[i].line_number == number then
            {
                me.ip = i
                return true
            }
        }
        runtimeError("?UNDEF'D STATEMENT ERROR")
        return false
    }

    run()
    {
        while true do
        {
            var instr = me.chunk[me.ip++]

            if instr.op == OpCode.OpReturn then
            {
                //print me.stack[>>]
                return true
            }
            else if instr.op == OpCode.OpConstant then
            {
                me.stack << instr.operand
            }
            else if instr.op == OpCode.OpNegate then
            {
                me.stack << -me.stack[>>]
            }
            else if instr.op == OpCode.OpAdd then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a + b)
            }
            else if instr.op == OpCode.OpSubtract then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a - b)
            }
            else if instr.op == OpCode.OpMultiply then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a * b)
            }
            else if instr.op == OpCode.OpDivide then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a / b)
            }
            else if instr.op == OpCode.OpPrint then
            {
                print me.stack[>>]
            }
            else if instr.op == OpCode.OpPop then
            {
                me.stack[>>]
            }
            else if instr.op == OpCode.OpGetVariable then
            {
                me.stack << me.variables[me.getVariableIndex(instr.operand)] //TODO
            }
            else if instr.op == OpCode.OpSetVariable then
            {
                const index = me.getVariableIndex(instr.operand)
                const value = me.stack[-1]
                if index == 0 then
                    me.variables = ([] << value) + me.variables[1:0]
                else
                    me.variables = (me.variables[0:index] << value) + me.variables[index+1:0]
                
            }
            else if instr.op == OpCode.OpGoto then
            {
                if !me.gotoLine(instr.operand) then return false
            }
        }
    }

}