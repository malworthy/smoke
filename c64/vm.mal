class NativeFunction
{
    init(name, function)
    {
        me.name = name
        me.function = function
    }
}

class ReturnItem
{
    init(loopVariable, stepSize, to, ip)
    {
        me.loopVariable = loopVariable
        me.stepSize = stepSize
        me.to = to
        me.ip = ip
    }

    isReturn() => me.loopVariable == "return"
}

class Vm
{
    init(chunk)
    {
        me.chunk = chunk
        me.ip = 0
        me.stack = []
        //me.returnStack = []
        me.variables = []
        me.functions = [NativeFunction("abs", me.absNative), NativeFunction("asc",me.ascNative)]
        
        for x in [0..65536]
            me.variables << 0

    }

    absNative(params)
    {
        const num = params[0]
        if type(num) != Type.Number then
        {
            me.runtimeError("?TYPE MISMATCH")
            return [false]
        }
        if num >= 0 then return [true, num] else return [true, -num]
    }

    ascNative(params)
    {
        const s = params[0]
        if type(s) != Type.String then
        {
            me.runtimeError("?TYPE MISMATCH")
            return [false]
        }
        if s == "" then
        {
            me.runtimeError("?ILLEGAL QUANTITY ERROR")
            return [false]
        }
        return [true, ascii(s)]
    }

    getVariableIndex(name)
    {
        var byte1 = 0
        var byte2 = 0

        name = upper(name)

        if len(name) == 1 then 
        {
            byte1 = 0
            byte2 = ascii(name[0])
        }
        else
        {
            byte1 = ascii(name[0])
            byte2 = ascii(name[1])
        }

        return byte1 * 128 + byte2
        
    }

    getVariable(name)
    {
        const func = me.functions where x => x.name == name
        if len(func) == 1 then 
        { 
            me.stack << func[0].function
            return true
        }
        const index = me.getVariableIndex(name)
        me.stack << me.variables[index]
        return true
    }

    runtimeError(message)
    {
        me.error = message
        print message
    }

    gotoLine(number)
    {
        var startip = 0
        if number > me.chunk[me.ip].line_number and me.ip < len(me.chunk)-1 then startip = me.ip + 1
        //print "len chunk: %{len(me.chunk)}"
        for i in [startip..len(me.chunk)-1]
        {
            //print "i: %{i}"
            if me.chunk[i].line_number == number then
            {
                me.ip = i
                return true
            }
        }
        me.runtimeError("?UNDEF'D STATEMENT ERROR")
        return false
    }

    jumpLine()
    {
        //print "*** IN JUMP LINE ***"
        const current = me.chunk[me.ip].line_number
        var line = current
        var p = me.ip
        while line == current and p < len(me.chunk)  do
        {
            p++
            if p >= len(me.chunk) then return false
            line = me.chunk[p].line_number  
            //print "jump line: %{line} curr: %{current} p: %{p}"
        }
        //if p >= len(me.chunk) then return false
        me.ip = p 

        return true
    }

    run(debug)
    {
        while true do
        {
            var instr = me.chunk[me.ip++]
            if debug then print "%{instr.toString()}"
            if instr.op == OpCode.OpReturn then
            {
                //print me.stack[>>]
                return true
            }
            else if instr.op == OpCode.OpConstant then
            {
                me.stack << instr.operand
            }
            else if instr.op == OpCode.OpNegate then
            {
                me.stack << -me.stack[>>]
            }
            else if instr.op == OpCode.OpAdd then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a + b)
            }
            else if instr.op == OpCode.OpSubtract then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a - b)
            }
            else if instr.op == OpCode.OpMultiply then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a * b)
            }
            else if instr.op == OpCode.OpDivide then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a / b)
            }
            else if instr.op == OpCode.OpAnd then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                if type(a) == Type.String or type(b) == Type.String then
                {
                    me.runtimeError("?TYPE MISMATCH ERROR")
                    return false
                }
                me.stack << bitand(a, b)
            }
            else if instr.op == OpCode.OpPrint then
            {
                write("%{me.stack[>>]}")
                write("%{instr.operand}")
            }
            else if instr.op == OpCode.OpPop then
            {
                me.stack[>>]
            }
            else if instr.op == OpCode.OpGetVariable then
            {
                me.getVariable(instr.operand)
            }
            else if instr.op == OpCode.OpSetVariable then
            {
                const index = me.getVariableIndex(instr.operand)
                const value = me.stack[-1]
                me.variables[index] = value
            }
            else if instr.op == OpCode.OpGoto then
            {
                if !me.gotoLine(instr.operand) then return false
            }
            else if instr.op == OpCode.OpGosub then
                me.stack << ReturnItem("return", 0, 0, (me.ip + 1))
            else if instr.op == OpCode.OpReturnSub then
            {
                if len(me.stack) == 0 then
                {
                    me.runtimeError("?RETURN WITHOUT GOSUB ERROR")
                    return false
                }
                const item = me.stack[>>]
                me.ip = item.ip
            }
            else if instr.op == OpCode.OpFor then
            {
                const step = me.stack[>>]
                const to = me.stack[>>]
                me.stack << ReturnItem(instr.operand, step, to, me.ip)
            }
            else if instr.op == OpCode.OpNext then
            {
                if len(me.stack) == 0 then
                {
                    me.runtimeError("?NEXT WITHOUT FOR ERROR")
                    return false
                }
                while !me.stack[-1].isReturn() and me.stack[-1].loopVariable != instr.operand and instr.operand != "" do
                {
                    me.stack[>>]
                    if len(me.stack) == 0 then
                    {
                        me.runtimeError("?NEXT WITHOUT FOR ERROR")
                        return false
                    }
                }
                const item = me.stack[-1]
                const index = me.getVariableIndex(item.loopVariable)
                var value = me.variables[index]
                value = value + item.stepSize
                if value <= item.to then
                {
                    me.variables[index] = value
                    me.ip = item.ip
                }
                
            }
            else if instr.op == OpCode.OpCall then
            {
                var func = me.stack[-(instr.operand + 1)]
                var params = me.stack[-instr.operand:0]
                for i in [0..instr.operand] me.stack[>>]
                const result = func(params)
                if !result[0] then return false

                me.stack << result[1]
            }
            else if instr.op == OpCode.OpEqual then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a == b)
            }
            else if instr.op == OpCode.OpGreater then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a > b)
            }
            else if instr.op == OpCode.OpGreaterEqual then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a >= b)
            }
            else if instr.op == OpCode.OpLess then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a < b)
            }
            else if instr.op == OpCode.OpLessEqual then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                me.stack << (a <= b)
            }
            else if instr.op == OpCode.OpNot then
            {
                me.stack[-1] = !me.stack[-1]
            }
            else if instr.op == OpCode.OpConcat then
            {
                const b = me.stack[>>]
                const a = me.stack[>>]
                if instr.operand then
                    me.stack << "%{a}\t%{b}"
                else
                    me.stack << "%{a}%{b}"
            }
            else if instr.op == OpCode.OpJumpIfFalse then
            {
                //print "top of stack: %{me.stack[-1]}"
                if !me.stack[-1] then 
                {
                    if !me.jumpLine() then
                        return true // no more code so just end program
                }
            }
            else if instr.op == OpCode.OpInput then
            {
                write("?")
                if instr.operand then write("?")
                write(" ")
                const val = input()
                me.stack << val
            }
            if debug then print me.stack
        }
    }

}
